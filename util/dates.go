package util

import (
	//"github.com/olebedev/when"
	"sync"
	"time"
	"unicode"
)

// ctime-no-ms
// Wed Dec 31 19:00:00

// ctme
// Wed Dec 31 19:00:00.000

// iso8601-utc
// 1970-01-01T00:00:00.000Z

// iso8601-local
// 1969-12-31T19:00:00.000+0500

// Some arbitrary length that is enforced before parsing date strings. In this case, a value of 10 includes the day,
// month, and two number date as a minimum. The time could, theoretically, be included in the minimum but it will all
// come out in the wash later.
const (
	DATE_FORMAT_CTIMENOMS     = DateFormat("Mon Jan _2 15:04:05")
	DATE_FORMAT_CTIME         = DateFormat("Mon Jan _2 15:04:05.000")
	DATE_FORMAT_CTIMEYEAR     = DateFormat("Mon Jan _2 2006 15:04:05.000")
	DATE_FORMAT_ISO8602_UTC   = DateFormat("2006-01-02T15:04:05.000Z")
	DATE_FORMAT_ISO8602_LOCAL = DateFormat("2006-01-02T15:04:05.000-0700")
)

type DateFormat string

type DateParser struct {
	order []DateFormat
	lock  sync.Mutex
}

var AllDateParser = DateParser{
	order: []DateFormat{DATE_FORMAT_CTIME, DATE_FORMAT_CTIMENOMS, DATE_FORMAT_CTIMEYEAR, DATE_FORMAT_ISO8602_UTC, DATE_FORMAT_ISO8602_LOCAL},
	lock:  sync.Mutex{},
}

var DATE_DAYS = []string{"Fri", "Mon", "Sat", "Sun", "Thu", "Tue", "Wed"}
var DATE_MONTHS = []string{"Apr", "Aug", "Dec", "Feb", "Jan", "Jul", "Jun", "Mar", "May", "Nov", "Oct", "Sep"}
var DATE_YEAR = time.Now().Year()

func NewDateParser(formats []DateFormat) *DateParser {
	return &DateParser{order: formats}
}

func (d DateParser) Clone() *DateParser {
	return &d
}

func (d *DateParser) ParseDate(value string) (time.Time, DateFormat, error) {
	var (
		date   time.Time
		err    error
		index  int
		picked DateFormat
	)

	for index = 0; index < len(d.order); index += 1 {
		if date, err = time.Parse(string(d.order[index]), value); err == nil {
			picked = d.order[index]
			if index > 0 && err == nil {
				d.reorder(index)
			}
			break
		}
	}

	return date, picked, err
}

func (d *DateParser) reorder(index int) {
	if index > 0 {
		var (
			format  DateFormat
			reorder = make([]DateFormat, len(d.order))
		)

		d.lock.Lock()
		copy(reorder, d.order)

		if index == len(d.order) {
			format, reorder = reorder[len(d.order)-1], reorder[:len(d.order)-1]
			reorder = append([]DateFormat{format}, reorder...)
		} else {
			format := reorder[index]
			reorder = append([]DateFormat{format}, append(reorder[:index], reorder[index+1:]...)...)
		}

		d.order = reorder
		d.lock.Unlock()
	}
}

func IsDay(match string) bool {
	return ArrayBinaryMatchString(match, DATE_DAYS)
}

// Takes string and returns if the string *looks* like an ISO formatted date,
// specifically the format generated by MongoDB (YYYY-MM-DDThh:mm:ss). This
// method ignores any additional information like milliseconds or timezones.
func IsIsoString(date string) bool {
	parts := []rune(date)

	return len(parts) >= 19 &&
		unicode.IsNumber(parts[0]) &&
		unicode.IsNumber(parts[1]) &&
		unicode.IsNumber(parts[2]) &&
		unicode.IsNumber(parts[3]) &&
		parts[4] == '-' &&
		unicode.IsNumber(parts[5]) &&
		unicode.IsNumber(parts[6]) &&
		parts[7] == '-' &&
		unicode.IsNumber(parts[8]) &&
		unicode.IsNumber(parts[9]) &&
		parts[10] == 'T' &&
		unicode.IsNumber(parts[11]) &&
		unicode.IsNumber(parts[12]) &&
		parts[13] == ':' &&
		unicode.IsNumber(parts[14]) &&
		unicode.IsNumber(parts[15]) &&
		parts[16] == ':' &&
		unicode.IsNumber(parts[17]) &&
		unicode.IsNumber(parts[18])
}

func IsMonth(match string) bool {
	return ArrayBinaryMatchString(match, DATE_MONTHS)
}

func IsTime(match string) bool {
	// 00:00:00.000
	check := []rune(match)
	size := len(check)

	if size == 8 {
		return unicode.IsNumber(check[0]) &&
			unicode.IsNumber(check[1]) &&
			check[2] == ':' &&
			unicode.IsNumber(check[3]) &&
			unicode.IsNumber(check[4]) &&
			check[5] == ':' &&
			unicode.IsNumber(check[6]) &&
			unicode.IsNumber(check[7])
	} else if size == 12 {
		return unicode.IsNumber(check[0]) &&
			unicode.IsNumber(check[1]) &&
			check[2] == ':' &&
			unicode.IsNumber(check[3]) &&
			unicode.IsNumber(check[4]) &&
			check[5] == ':' &&
			unicode.IsNumber(check[6]) &&
			unicode.IsNumber(check[7]) &&
			check[8] == '.' &&
			unicode.IsNumber(check[9]) &&
			unicode.IsNumber(check[10]) &&
			unicode.IsNumber(check[11])
	} else {
		return false
	}
}
